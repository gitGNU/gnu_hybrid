#
# Copyright (C) 2008 Francesco Salvestrini
#                    Alessandro Massignan <ff0000.it@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

BEGIN {
	PROGNAME = "sections";

	lib_init();

	outfile       = "/dev/stdout";
	infiles_cnt   = 0;

	dump          = 0;
	dump_total    = 0;
	dump_size     = 0;
	dump_vma      = 0;
	dump_lma      = 0;
	dump_flags    = 0;
	dump_percent  = 0;

	zero          = 0;
	fatal         = 0;
	sections_list = "";
	word_size     = 0;

	opts   = "o:TSLVFPzfvdh";
	h_desc = "Retrieve object files sections";
	h_note = "Place input files at last, using -- as separator";

	opt_desc["T"] = "display total sections size";
	opt_desc["S"] = "display each section size";
	opt_desc["L"] = "display each section lma";
	opt_desc["V"] = "display each section vma";
	opt_desc["F"] = "display each section flags";
	opt_desc["P"] = "display each section % size";
	opt_desc["z"] = "warn on zero size sections";
	opt_desc["f"] = "warnings are fatal";
	opt_desc["o"] = "set the output file";
	opt_desc["v"] = "enable verbose output";
	opt_desc["d"] = "enable debugging";
	opt_desc["h"] = "display this help and exit";

	while ((c = getopt(ARGC, ARGV, opts)) != -1) {
		if (c == "o") {
			outfile = optarg;
		} else if (c == "T") {
			dump_total = 1;
		} else if (c == "S") {
			dump_size = 1;
		} else if (c == "L") {
			dump_lma = 1;
		} else if (c == "V") {
			dump_vma = 1;
		} else if (c == "F") {
			dump_flags = 1;
		} else if (c == "P") {
			dump_percent = 1;
		} else if (c == "z") {
			zero = 1;
		} else if (c == "f") {
			fatal = 1;
		} else if (c == "v") {
			_verbose = 1;
		} else if (c == "d") {
			_debug = 1;
		} else if (c == "h") {
			help(1, h_desc, h_note, opts, opt_desc);
			exit(0);
		} else if (c == ":") {
			hint("");
			exit(1);
		} else if (c == "?") {
			hint("");
			exit(1);
		} else {
			not_reachable();
		}
	}

	for (i = 0; optind < ARGC; optind++) {
		if (!readable(ARGV[optind])) {
			error(ARGV[optind] " is not readable!\n");
			exit(1);
		}
		i++;
		infiles[i] = ARGV[optind];
	}
	infiles_cnt = i;

	if (infiles_cnt <= 0) {
		hint("Missing input file(s)");
		exit(1);
	}

	if (outfile == "") {
		hint("Missing output file name");
		exit(1);
	}
	if (!writable(outfile)) {
		error(outfile " is not writable!\n");
		exit(1);
	}
	debug("outfile = " outfile "\n");

	#if (!dump_total   &&
	#    !dump_size    &&
	#    !dump_vma     &&
	#    !dump_lma     &&
	#    !dump_flags   &&
	#    !dump_percent) {
	#	hint("Missing display option");
	#	exit(1);
	#}
	if (dump_total   ||
	    dump_size    ||
	    dump_vma     ||
	    dump_lma     ||
	    dump_flags   ||
	    dump_percent) {
		dump = 1;
	} else {
		dump = 0;
	}

	if ((dump_total) &&
	    (dump_size || dump_vma || dump_lma || dump_flags)) {
		hint("Conflicting options");
		exit(1);
	}

	assert("@OBJDUMP@" != "");
	assert(executable(remove_parameters("@OBJDUMP@")));

	delete sections;
	delete sizes;
	delete sizes_sum;
	delete vmas;
	delete lmas;
	delete flags;

	for (i = 1; i <= infiles_cnt; i++) {
		count = 0;
		pipe  = "@OBJDUMP@ -w -h " infiles[i];

		debug("Processing file `" infiles[i] "`\n");

		if (dump && !dump_total) {
			printf("%s:\n", infiles[i]);
		}

		while ((pipe | getline string) > 0) {
			string = strcleanspc(string);

			if (match(string,
				  /^[0-9][0-9]* \.[a-zA-Z0-9_][a-zA-Z0-9_]* [0-9a-fA-F][0-9a-fA-F]* [0-9a-fA-F][0-9a-fA-F]* [0-9a-fA-F][0-9a-fA-F]* [0-9a-fA-F][0-9a-fA-F]* 2\*\*[0-9][0-9]*.*$/) != 0) {
				split(string, line, " ");
				name = line[2];

				if (dump && dump_total &&
				    (index(sections_list, name"\n") == 0)) {
					debug("Initializing size counter " \
					      "for section `" name "`\n");

					sizes_sum[name] = 0;
					sections_list   = name "\n" \
						sections_list;
				}

				size = line[3];
				vma  = line[4];
				lma  = line[5];

				sub(/^.*2\*\*[0-9][0-9]* /, "", string);
				flag = string;

				assert(length(size) == length(vma));
				assert(length(vma)  == length(lma));

				if (word_size < length(size)) {
					word_size = length(size);
				}

				debug("Got section "	\
				      name " / "	\
				      size " / "	\
				      vma  " / "	\
				      lma  " / "	\
				      flag		\
				      "\n");

				# Avoid size to be recognized as
				# octal number by strtonum()
				if (dump && dump_total) {
					gsub(/^0{2.}/, "", size);
				}

				sections[name] = 1;
				sizes[name]    = size;
				vmas[name]     = vma;
				lmas[name]     = lma;
				flags[name]    = flag;

				if (dump && dump_total) {
					sizes[name] = "0x" sizes[name];
					sizes_sum[name] =		    \
						sizes_sum[name] +	    \
						hex2int(sizes[name]);
				}
			}
		}
		close(pipe);

		if (zero && (sizes[name] == 0)) {
			warning("Section `" name "` has zero size\n");
			if (fatal) {
				exit(1);
			}
		}

		for (name in sections) {
			count++;
		}
		debug("Got " count " input sections\n");

		# Dump sections list
		if (dump && !dump_total) {
			total         = 0;
			format_length = 0;

			if (dump && dump_percent) {
				for (name in sections) {
					total         = total + sizes[name];
					format_length = max(format_length,
							    length(name));
				}
			}

			for (name in sections) {

				printf("   ") > outfile;

				if (dump && dump_size) {
					printf(" 0x%" word_size "s",
					       sizes[name]) > outfile;
				}

				if (dump && dump_lma) {
					printf(" 0x%" word_size "s",
					       lmas[name])  > outfile;
				}

				if (dump && dump_vma) {
					printf(" 0x%" word_size "s",
					       vmas[name])  > outfile;
				}

				printf(" %-" format_length "s", name) > outfile;

				if (dump && dump_flags) {
					printf(" [ %s ]",
					       flags[name]) > outfile;
				}

				if (dump && dump_percent) {
					# 0  -> Pad with zero
					# 4  -> Maximum length
					# .1 -> decimals length
					printf(" [ %04.1f%% ]",
					       sizes[name] / total * 100) \
						> outfile;
				}

				printf("\n") > outfile;
			}

			printf("\n") > outfile;
		}
	}

	# Dump total section list
	if (dump && dump_total) {
		printf("Grand-total:\n") > outfile;

		total         = 0;
		format_length = 0;

		for (name in sections) {
			total         = total + sizes_sum[name];
			format_length = max(format_length,
					    length(name));
		}

		for (name in sections) {
			printf("    ") > outfile;

			printf("0x%0" word_size "x %-" format_length "s ",
			       sizes_sum[name], name) > outfile;

			if (dump && dump_percent) {
				printf("[ %2.2f ]",
				       sizes_sum[name] / total * 100) \
					> outfile;
			}

			printf("\n") > outfile;
		}
	}

	if (dump) {
		close(outfile);
	}

	exit(0);
}

END {
	lib_fini();
}
