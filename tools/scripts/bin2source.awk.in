#
# Copyright (C) 2008 Francesco Salvestrini
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

function dumpbuffer(buffer, bytes_per_row)
{
	for (i = 1; i < (length(buffer) + 1); i++) {
		if ((position % bytes_per_row) == 0) {
			start = "\t";
			stop  = "";
		} else if ((position % bytes_per_row) == (bytes_per_row - 1)) {
			start = "";
			stop  = "\n";
		} else {
			start = "";
			stop  = "";
		}
		
		printf("%s0x%02x, %s",
		       start, ord(substr(buffer, i, 1)), stop) > outfile;
		
		position++;
	}
}

BEGIN {
	PROGNAME = "bin2source";

	lib_init();

	bytes    = 0;
	position = 0;
	infile   = "/dev/stdin";
	outfile  = "/dev/stdout";
	name     = "data";
	columns  = 8;
	style    = "";

	opts   = "i:o:n:c:xXvdh";
	h_desc = "Transform a raw binary file into a C file"; 
	h_note = "";

	opt_desc["i"] = "set the input file";
	opt_desc["o"] = "set the output file";
	opt_desc["n"] = "set the embedded structure name";
	opt_desc["c"] = "set the columns per line";
	opt_desc["x"] = "set output style for C language";
	opt_desc["X"] = "set output style for C++ language";
	opt_desc["v"] = "enable verbose output";
	opt_desc["d"] = "enable debugging";	
	opt_desc["h"] = "display this help and exit";

	while ((c = getopt(ARGC, ARGV, opts)) != -1) {
		if (c == "i") {
			infile = optarg;
		} else if (c == "o") {
			outfile = optarg;
		} else if (c == "n") {
			name = optarg;
		} else if (c == "x") {
			style = "C";
		} else if (c == "X") {
			style = "C++";
		} else if (c == "c") {
			columns = optarg;
		} else if (c == "d") {
			_debug = 1;
		} else if (c == "v") {
			_verbose = 1;
		} else if (c == "h") {
			help(0, h_desc, h_note, opts, opt_desc);
			exit(0);
		} else if (c == ":") {
			hint("");
			exit(1);
		} else if (c == "?") {
			hint("");
			exit(1);
		} else {
			not_reachable();
		}
	}

	if (infile == "") {
		hint("Missing input file name");
		exit(1);
	}
	if (!readable(infile)) {
		error(infile " is not readable!\n");
		exit(1);
	}
	debug("infile  = " infile "\n");

	if (outfile == "") {
		hint("Missing output file name");
		exit(1);
	}
	debug("outfile = " outfile "\n");

	if (name == "") {
		hint("Structure name is missing");
		exit(1);
	}

	if (columns < 1) {
		hint("Wrong columns per line");
		exit(1);
	}
	
	if (toupper(style) == "C") {

		c_header(outfile);

		c_comment(outfile, "Data gathered from file " infile);

		printf("const char %s[] = {\n", name);
		while ((getline buffer < infile) > 0) {
			bytes = bytes + length(buffer);
			dumpbuffer(buffer, columns);
		}
		printf("\n};\n") > outfile;
		
		c_footer(outfile, bytes " bytes processed");

	} else if (toupper(style) == "C++") {

		cxx_header(outfile);

		cxx_comment(outfile, "Data gathered from file " infile);

		printf("const char %s[] = {\n", name);
		while ((getline buffer < infile) > 0) {
			bytes = bytes + length(buffer);
			dumpbuffer(buffer, columns);
		}
		printf("\n};\n") > outfile;
		
		cxx_footer(outfile, bytes " bytes processed");

	} else if (style != "") {
		hint("Unknown output style `" style "`");
		exit(1);
	} else {
		hint("Missing output style");
		exit(1);
	}
	
	close(infile);
	close(outfile);

	exit(0);
}

END {
	lib_fini();
}
